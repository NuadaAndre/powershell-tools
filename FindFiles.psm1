function Export-FileList {
    <#
    .SYNOPSIS
    Connects to a target and downloads a full list of files.

    .DESCRIPTION
    Maps a PSDrive to the specified host(s) and downloads a list of files from the target directory. This list is
    then filtered and exported to CSV. The CSV can be used as input to the Get-File function by deleting any
    files that you don't want to download and then using the result as input.

    .NOTES
    Author:  Liam Somerville
    License: GNU GPLv3

    Original one-liner came from @harmj0y > https://gist.github.com/HarmJ0y/868c1cb0a09be5427c73

    .PARAMETER ComputerName
    String or array containing target computer(s).

    .PARAMETER Drive
    Optional parameter containing the target drive(s). Defaults to C.

    .PARAMETER Directory
    Optional parameter containing the target directory. Defaults to blank.

    .PARAMETER OutputPath
    Location to store output CSV.

    .EXAMPLE
    PS C:\> Export-FileList -ComputerName FOO1 -Drive C -Directory Temp -OutputPath C:\Path\To\Output
    #>

    [CmdletBinding()]

    Param (
        [Parameter(Mandatory = $True,
                   ValueFromPipeline = $True)]
        [string[]]
        $ComputerName,

        [string[]]
        $Drive = 'C',

        [string]
        $Directory,

        [string]
        [ValidateScript({Test-Path -Path $_})]
        $OutputPath = $PSScriptRoot,

        [System.Management.Automation.PSCredential]
        $Credential = [Management.Automation.PSCredential]::Empty
    )

    begin {
        $PSDriveName = 'FDDrive'
        Write-Verbose -Message "[*] Beginning file enumeration..."
    }

    process {
        foreach ($Computer in $ComputerName) {
            $OutputFile = "$OutputPath\$Computer-files.csv"
            # TODO: Is there a nicer way of doing these paths? Since we have known inputs, perhaps we can just
            # combine variables and strings. Same elsewhere in the script.
            $TargetPath = Join-Path -Path "\\$Computer" -ChildPath "$Drive$"

            # If a directory is specified, add it to the path.
            if ($Directory) {
                Write-Verbose -Message "[*] Directory provided. Adding to target path..."
                $TargetPath = Join-Path -Path $TargetPath -ChildPath $Directory
            }

            try {
                # Need -ErrorAction Stop so we can catch the error
                Write-Verbose -Message "[*] Mapping PSDrive: $TargetPath"
                New-PSDrive -Name $PSDriveName -PSProvider FileSystem -Root $TargetPath -Credential $Credential -ErrorAction Stop | Out-Null
            }
            catch {
                Write-Error -Message "[-] Unable to connect to $Computer!"
                Continue
            }

            # We pipe to PSIsContainer rather than use -File for PowerShell v2.0 compliance. If you want to modify
            # the values retrieved from each file, this is where you'd do it (LastAccessTime, etc.)
            Get-ChildItem -Path "$PSDriveName`:\" -Recurse -ErrorAction SilentlyContinue |
            Where-Object {!$_.PSIsContainer} |
            Select-Object FullName, @{Name = 'Owner';Expression = {(Get-Acl $_.FullName).Owner}},
                                      LastAccessTime, LastWriteTime, Length |
            Export-CSV -NoTypeInformation -Path $OutputFile
            Write-Verbose -Message "[+] $Computer results: $OutputFile"
            Remove-PSDrive $PSDriveName
        }
    }

    end {
        Write-Verbose -Message "[*] Work complete!"
    }
}

function Get-File {
    <#
    .SYNOPSIS
    Imports a CSV generated by Export-FileList and downloads all files remaining.

    .DESCRIPTION
    The input CSV for this function should be in the same format as the one generated by Export-FileList. Delete
    any files you *don't* want from that list and then use it as input for this one. All files will be downloaded
    to a subfolder, named for the source computer, in the specified directory ($OutputPath). Defaults to the
    current one.

    .NOTES
    Author: Liam Somerville
    License: GNU GPLv3

    .PARAMETER TargetFiles
    CSV containing target files.

    .PARAMETER OutputPath
    Directory to store retrieved files in. A subfolder will be created for each host.

    .EXAMPLE
    PS C:\>Get-File.ps1 -TargetFiles targets.csv -OutPath C:\Path\To\Output
    #>

    [CmdletBinding()]

    Param (
        [Parameter(Mandatory = $True)]
        [string]
        [ValidateScript({Test-Path -Path $_})]
        $TargetFiles,

        [Parameter(Mandatory = $True)]
        [string]
        [ValidateScript({Test-Path -Path $_})]
        $OutputPath,

        [System.Management.Automation.PSCredential]
        $Credential = [Management.Automation.PSCredential]::Empty
    )

    begin {
        $PSDriveName = "FDDrive"
        Write-Verbose -Message "[*] Importing target file list..."
        $FileList = Import-Csv -Path $TargetFiles

        # Grab the computer name from the first row of the imported CSV
        $ComputerName = $FileList[0].FullName.Split("\")[2]

        # Grab the drive letter from the first row of the imported CSV
        $Drive = $FileList[0].FullName.Split("\")[3]
        $TargetPath = Join-Path -Path "\\$ComputerName" -ChildPath $Drive
        try {
            # Need -ErrorAction Stop so we can catch the error
            Write-Verbose -Message "[*] Mapping PSDrive: $TargetPath"
            New-PSDrive -Name $PSDriveName -PSProvider FileSystem -Root $TargetPath -Credential $Credential -ErrorAction Stop | Out-Null
        }
        catch {
            Write-Error -Message "[-] Unable to connect to $Computer!"
        }
    }

    process {
        foreach ($File in $FileList) {
            # Grab the computer name from the file output
            $FileComputerName = $File.FullName.Split("\")[2]

            # Grab the drive letter from the file output
            $FileDrive = $File.FullName.Split("\")[3]

            # If either the target computer or target drive has changed, remap
            if (($ComputerName -ne $FileComputerName) -or ($Drive -ne $FileDrive)) {
                Write-Verbose -Message "[*] Target changed. Removing $PSDriveName mapping..."
                Remove-PSDrive -Name $PSDriveName
                $TargetPath = Join-Path -Path "\\$FileComputerName" -ChildPath $FileDrive
                try {
                    # Need -ErrorAction Stop so we can catch the error
                    Write-Verbose -Message "[*] Mapping PSDrive: $TargetPath"
                    New-PSDrive -Name $PSDriveName -PSProvider FileSystem -Root $TargetPath -Credential $Credential -ErrorAction Stop | Out-Null
                }
                catch {
                    Write-Error -Message "[-] Unable to connect to $Computer!"
                    Continue
                }
            }

            Write-Verbose -Message "[+] Copying $($File.FullName)..."
            $OutputSubfolder = Join-Path -Path $OutputPath -ChildPath $ComputerName
            # If an appropriate subfolder doesn't exist, create one
            if (!(Test-Path -Path $OutputSubfolder)) {
                New-Item -ItemType Directory -Path $OutputSubfolder
            }
            Copy-Item -Path $File.FullName -Destination $OutputSubfolder
        }
    }

    end {
        Write-Verbose -Message "[*] Removing $PSDriveName mapping..."
        Remove-PSDrive -Name $PSDriveName
    }
}
